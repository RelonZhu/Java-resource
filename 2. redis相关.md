## 1.什么是redis？
redis是基于内存的高性能key-value类型数据库，支持多客户端
## 2.常见数据结构及实现
     • string
     • list
     • set
     • hash
     • zset
     • GeoHash
     • BitMaps
     • HyperLogLogs
## 3.为什么字符串要使用SDS作为其底层实现？
## 4.【重要】字典如何实现？渐进式rehash的过程是？
hash算法使用MurMurHash算法，优势是无论数据输入情况如何都能够给出随机分布性较好的哈希值并且效率较高
字典结构
通常的rehash步骤：分配新空间 -》逐个迁移数据 -》交换hash表
一般过程：

     1. 先在ht[1]上进行扩容/缩容，目标大小为第一个大于或等于ht[0].used * 2的2^n，比如ht[0] * used = 400，那目标大小应为2^9 = 512
     2. 将ht[0]上的所有元素重新计算hash值，并全部迁移到ht[1]上
     3. 待全部迁移完成后，释放ht[0],将ht[1]设置成ht[0]，并在ht[0]上创建新的空白hash表，以备下次hash
渐进式hash：非一次性完成，因为当服务器中数据量很大时，rehash过程可能会导致服务器在很长一段时间内停止服务

     1. 为ht[1]分配空间，方式同一般方式一致
     2. 将rehashidx设置成0，表示rehash工作正式开始，同时，随着rehash过程的进行，rehashidx不断递增，该值表示正在迁移的键值对索引值
     3. rehash过程中，当发生增删改查操作时，会顺带将ht[0]哈希表中rehashidx位置上的键值对计算hash值并rehash到ht[1]中，同时，rehashidx + 1，指向下一个要rehash的键值对
     4. 随着增删改查操作不断进行，ht[0]上的键值对会不断rehash到ht[1]上，最后将rehashidx设置为-1代表rehash过程结束
## 5. 4.0之前版本的Redis的单线程运行模式？
本质上Redis并非单纯的单线程服务模型，一些辅助工作如持久化刷盘、惰性删除等任务是由BIO线程完成的。单线程主要是指与客户端交互完成命令请求和回复的过程。
### 5.1单线程模式的考量
     • CPU并非是Redis的性能瓶颈，Redis主要是利用内存进行各种操作，处理速度已然很快，借助多线程进行处理的效率提升不够明显
     • 复杂的value类型。当value很大时，如果使用多线程，那势必就需要加锁进行同步，如此就可能导致死锁
     • 集群化扩展。如果按照上面的原因，通过key计算hash，然后将hash值相同的key交给同一个线程处理就能够解决，但是对集群而言，可能每台机器生成的线程号是一致的，而且集群化的redis其实相当于将单线程模式扩展了
     • 软件工程角度。单线程更易开发维护
### 5.2 Redis的文件事件和时间事件
     • 时间事件
          a. 定时事件：任务在等待指定大小的等待时间之后就执行，执行完成就不再执行，只触发一次；
          b. 周期事件：任务每隔一定时间就执行，执行完成之后等待下一次执行，会周期性的触发，主要进行一些辅助任务；
周期事件包括：

     1. 删除数据库的key
     2. 触发RDB和AOF持久化
     3. 主从同步
     4. 集群化保活
     5. 关闭清理死客户端连接
     6. 统计更新服务器内存、key数量等
时间事件原理
时间事件是存储在链表中，按照ID存储的，并不是按照即将被执行的顺序存储的，因而获取最近要执行的事件时，都需要进行O(N)遍历，但由于时间事件较少，效率不会有太大影响。
### 5.3 单线程模式中事件调度和执行
Redis轮流处理文件事件和时间事件，两类事件都是有序原子执行的，且不会终止正在执行的事件
     • 调度规则
Redis服务器是边阻塞边执行的，具体的阻塞事件由最近待执行时间事件的等待时间决定的，在阻塞该最小等待时间返回之后，开始处理事件任务，并且先执行文件事件、再执行时间事件，所有即使时间事件要即刻执行，也需要等待文件事件完成之后再执行时间事件，所以比预期的稍晚
## 6.Redis的反应堆模式的认识
     • epoll/kqueue是什么？
     • 什么是Reactor模式？
     反应堆模式是一种对象行为的设计模式，主要同于同步IO，在epoll/kqueue的基础上进行业务区分，并且对每一种业务设置相应的处理函数，每次来任务之后对任务进行识别和分发，每种处理函数只处理一种业务，这种模型更加符合OO的设计理念，这也是Reactor反应堆模式的设计思路
     图中给出了5个部件分别为：
          1. handle 可以理解为读写事件 可以注册到Reactor进行监控
          2. Sync event demultiplexer 可以理解为epoll/kqueue/select等作为IO事件的采集器
          3. Dispatcher 提供注册/删除事件并进行分发，作为事件分发器
          4. Event Handler 事件处理器 完成具体事件的回调 供Dispatcher调用
          5. Concrete Event Handler 具体请求处理函数   
     • redis中Reactor模式的实现
## 7.【重要】持久化及基本原理
方式：
RDB：以二进制方式保存快照
AOF：以协议文本方式保存所有的操作命令和参数记录记录到AOF文件，从而记录数据库状态

     • RDB的SAVE与BGSAVE
     RBD由于使用快照的方式，恢复时间较短，且RDB文件都是完整的，不会损坏，并且RDB文件经过压缩，文件占用空间较小，但是由于RDB方式保存的只是快照，所以会出现两个备份周期之间数据丢失的情况，数据较重要，不建议采用此方式
     • SAVE
     SAVE方式是阻塞的，使用主进程进行备份直到备份完成，如果数据量较大，这个过程可能会导致较长时间的阻塞
     • BGSAVE
     备份时会fork一个主线程进行备份操作，备份完成后将原有RDB文件替换掉
     • AOF详解
     Redis通过write函数将每一个服务端的写命令及参数都记录下来，进而保存数据库状态，该方式数据不易丢失，但恢复速度相比RDB而言较慢
     开启AOF后，服务端每执行一次写命令都会讲命令放入AOF缓冲区末尾，然后将AOF缓冲区的内容写入文件，而何时将文件同步到磁盘由appendfsync配置
          • always:效率低，最安全
          • everysec：always的折中方案，仅会丢失1S的数据
          • no：由系统控制，数据完整性相对较差
AOF重写缓存
## 8.【重要】Redis的ZIPLIST的底层设计和实现
     • zlentry的实现
          a. prevlen
               使用该方式的原因有二，一是为了节约内存，二是由于压缩列表存储数据的多样性，无法像数组那样直接通过偏移量计算出前面的节点，因此使用这个值，记录上一个节点的大小来完成向前指向
               **prevlen属性以字节为单位，记录了压缩列表中前一个节点的长度，其长度可以是 1 字节或者 5 字节**：
               ⅰ. 如果前一节点的长度小于254字节，那么prevlen属性的长度为1字节， 前一节点的长度就保存在这一个字节里面。
               ⅱ. 如果前一节点的长度大于等于254字节，那么prevlen属性的长度为5字节,第一字节会被设置为0xFE，之后的四个字节则用于保存前一节点的长度。
          b. encoding和content存储
               encoding编码取决于content的类型和长度
                    1. encoding部分分为三种类型：1字节、2字节、5字节 
                    2. 最高2bit表示是哪种长度的字符串 分别是00 01 10 各自对应1字节 2字节 5字节
                    3. 当最高2bit=00时 表示encoding=1字节 剩余6bit 2^6=64 可表示范围0~63
                    4. 当最高2bit=01时 表示encoding=2字节 剩余14bit 2^14=16384 可表示范围0~16383
                    5. 当最高2bit=11时 表示encoding=5字节 比较特殊 用后4字节 剩余32bit 2^32=42亿多
                    ############################字符串存储和整数存储的分界线####################*
                    高2bit固定为11 其后2bit 分别为00 01 10 11 表示存储的整数类型
Q：为什么prevlen的长度要么是1字节要么是5字节呢？为啥没有2字节、3字节、4字节这些中间态的长度呢？
要解答这个问题就引出了今天的一个关键问题：连锁更新问题

     * 连锁更新
     当插入一个长度大于254字节长度的节点时，其后面节点的prevlen如果之前是1字节，那么就将面临拓展的问题，从1个字节扩展到5个字节，那么极端情况下，后面所有的节点都需要扩展，由此便产生了连锁更新
     所以直接扩大到5字节，能够大大降低产生连锁更新的概率，这种小程度的内存浪费是值得的
## 9.【重要】Redis的ZSET和跳跃链表的问题
ZSET同时包含字典和跳跃链表(skiplist)两种结构
跳表按score从小到大保存所有集合元素；字典保存这从member到score的映射；两种结构通过指针共享相同元素的member和score，不浪费额外内存
布局如下：
### 9.1 ZSET中跳表的实现细节
• 随机层数的实现原理
## 10.【重要】redis内存回收机制

     1. 回收的内存从哪里来
     redis内存占用从大维度上来看，也就是键值对数据占用的，另一部分就是redis本身运行所占用的空间
     2.几个问题
          • 带过期超时的键值对存储在哪里？
          • 如何判断带超时的键值对是否可以被删除了？
          带过期时间的键值对会放在expires（过期字典）下，过期字典的key是指向对应对象的指针，value保存Unix时间戳（通过EXPIRE和PEXPIRE设置的相对时长也会最终转换成时间戳），当判断存在改对象并且过期时间戳和当前时间戳相对大小后，会根据判断结果决定是否删除键
          • 删除机制有哪些以及如何选择？

               a. 定时删除：设置键值时，同时创建定时器，过期时间一到，立即删除对应的键值对
               b. 定期删除：每隔特定的时间对数据库进行扫描，删除过期的键值对
               c. 惰性删除：暂时不会进行删除
     3.内存淘汰机制

          • noeviction：内存不足时，新写入操作报错
          • allkeys-lru：在所有键值对中移除最近最少使用的
          • allkeys-random：在所有键值对中随机移除
          • volatile-lru：在设置了过期时间的键值对中移除最近最少使用的
          • volatile-random：在设置了过期时间的键空间中，随机移除
          • volatile-ttl：在设置了过期时间的键空间中，优先移除更早过期时间的键
## 11.【重要】redis数据同步机制与原理

     1.Redis中CAP理论
     当Redis多台机器分布在不同的网络中，如果出现网络故障，那么数据一致性和服务可用性无法兼顾，Redis系统对此必须做出选择，事实上Redis选择了可用性，或者说Redis选择了另外一种最终一致性。
     2.最终一致性和复制
     Redis采用最终一致性保证CAP理论的一致性，也就是不会保证主从节点数据不会在任何时刻都是一致的，并且Redis主从同步默认是异步的
     从从复制：
     3.全量复制和增量复制
          • 全量复制
     从节点因为故障恢复或者新添加节点时的数据初始化阶段的数据复制，这个阶段会将主节点所有数据全量同步到从节点，成本高但不可避免
     过程分析
     全量复制共分为三个阶段    
          • 快照阶段
     从节点向主节点发送SYNC命令，代表需要进行全量复制，主节点执行bgsave命令将内存数据保存成快照发送至从节点，从节点接收并解析快照，主节点同时将新增命令保存至缓冲区
          • 缓冲阶段
     主节点向从节点发送缓冲区的命令，这部分命令时主节点执行bgsave后到从节点载入快照的时间段内主节点的新增命令
          • 增量阶段
     缓冲同步完成后，主节点向从节点同步增量操作命令，至此基本保持一致
## 12.【重要】复制详细过程
当服务器执行指令 `slaveof ip port` 时，就表明成为redis服务器ip:port的从服务器，然后将从主服务器上进行数据同步。
从服务器上线后，会先进行全量复制：过程如下
a. 向主服务器发送SYNC命令
b. 主服务器接收到SYNC命令后，执行BGSAVE命令生成RDB文件，同时将新增命令添加进缓冲区
c. 备份完成后，主服务器将RDB文件发送到从服务器，从服务器接收到文件后开始解析并同步备份文件
d. 主服务器将缓冲区内的数据发送给从服务器
## 13.【重要】基于Redis的分布式锁和Redlock算法
• 什么是Redlock算法
是Antirez在单redis节点上引入的高可用模式
• 工作过程
• 获取当前Unix时间，以毫秒为单位
• 依次尝试从5个实例，使用相同的key和具有唯一性的value获取锁
当向Redis请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间，这样可以避免客户端死等
• 客户端使用当前时间减去开始获取锁时间就得到获取锁使用的时间。当且仅当从半数以上的Redis节点取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功
• 如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间，这个很重要
• 如果因为某些原因，获取锁失败（没有在半数以上实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁，无论Redis实例是否加锁成功，因为可能服务端响应消息丢失了但是实际成功了，毕竟多释放一次也不会有问题
## 14.【重要】高可用相关内容

     1.Sentinel(哨兵)
          • 哨兵的主要功能
               a. 集群监控
               b. 消息通知
               c. 故障转移
               d. 配置中心
          • 哨兵原理解析
          • SDOWN 和 ODOWN
          SDOWN状态：当其中一个哨兵发现master宕机，则master被标记为该状态，即主观宕机
          ODOWN状态：当quorum个数量的哨兵都觉得master宕机，那么就会被标记为该状态，客观宕机
          sdown打成的条件：一个烧饼ping一个master，超过is-master-down-after-milliseconds指定        的毫秒数之后，主观认为master宕机了
          sdown到odown转换的条件：如果一个烧饼在指定的时间内，收到quorum指定数量的其他烧        饼也认为master是sdown，那么就认为odown了，客观认为master宕机
          • 哨兵自动发现机制
          通过pub/sub实现的，沟通内容是自己的ip、runid还有对master的监控配置
          • slave —> master的选举算法
          • 与master断开连接的时长
          • slave优先级
          • 复制文件数量(offset)
          • runid大小
          如果一个slave跟master断开连接已经超过了down-after-milliseconds的10倍，外加master宕机的时长，那么slave就被认为不适合选举为master
          (down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state
          接下来会对slave进行排序：
          （1）按照slave优先级进行排序，slave priority越低，优先级就越高
          （2）如果slave priority相同，那么看replica offset，哪个slave复制了越多的数据，offset越靠后，优先级就越高
          （3）如果上面两个条件都相同，那么选择一个run id比较小的那个slave
## 14.【重要】缓存穿透、缓存击穿、缓存雪崩

     • 缓存穿透
缓存穿透
